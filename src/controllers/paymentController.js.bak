import { MESSAGES, PACKAGES, SUPPORTED_CRYPTO, REFERRAL_ENABLED, REFERRAL_TYPE_KEYBOARD, ABOUT_KEYBOARD } from '../config.js';
import { createCryptoKeyboard, createChainKeyboard, createPaymentCryptoKeyboard, createAfterPaymentKeyboard, createMainMenuKeyboard } from '../screens/keyboards.js';
import { PaymentCryptoService } from '../services/PaymentCrypto.service.js';
import { PaymentFiatService } from '../services/PaymentFiat.service.js';
import { UserService } from '../services/User.service.js';
import { OrderService } from '../services/Order.service.js';
import { ReferralService } from '../services/Referral.service.js';
import { GenerationService } from '../services/Generation.service.js';

const paymentCryptoService = new PaymentCryptoService();
const paymentFiatService = new PaymentFiatService();
const userService = new UserService();
const orderService = new OrderService();
const referralService = new ReferralService();
const generationService = new GenerationService();

// Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ½Ğ° callback query (Ğ¸Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ "query is too old")
async function safeAnswerCbQuery(ctx, text = null) {
    try {
        if (text) {
            await ctx.answerCbQuery(text);
        } else {
            await ctx.answerCbQuery();
        }
    } catch (error) {
        if (error.description && error.description.includes('query is too old')) {
            console.log('âš ï¸ Query is too old, ignoring...');
        } else {
            console.error('âŒ Error in answerCbQuery:', error);
        }
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº "ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ²Ğ¸Ğ´ĞµĞ¾"
export async function handleBuy(ctx) {
    try {
        await ctx.answerCbQuery(); // Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¸Ğ½Ğ´Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸
        // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ²
        const packageButtons = Object.keys(PACKAGES).map(key => {
            const pkg = PACKAGES[key];
            const discount = pkg.discount ? ` ğŸ”¥ -${pkg.discount}` : '';
            return [{
                text: `${pkg.emoji} ${pkg.title} - ${pkg.rub}â‚½${discount}`,
                callback_data: `select_package_${key}`
            }];
        });
        
        await ctx.editMessageText(MESSAGES.CHOOSE_PACKAGE, {
            reply_markup: {
                inline_keyboard: [
                    ...packageButtons,
                    [{ text: 'ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´', callback_data: 'main_menu' }]
                ]
            }
        });
    } catch (err) {
        console.error('âŒ Error in handleBuy:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ°ĞºĞµÑ‚Ğ°
export async function handleSelectPackage(ctx, packageKey) {
    try {
        const pkg = PACKAGES[packageKey];
        if (!pkg) {
            return await ctx.answerCbQuery('ĞŸĞ°ĞºĞµÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½', { show_alert: true });
        }
        
        // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ°ĞºĞµÑ‚ Ğ² ÑĞµÑÑĞ¸Ğ¸
        ctx.session = ctx.session || {};
        ctx.session.selectedPackage = packageKey;
        
        let message = `${pkg.emoji} ${pkg.title}\n\n`;
        message += `ğŸ’ Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹: ${pkg.generations}\n`;
        message += `ğŸ’° Ğ¦ĞµĞ½Ğ°: ${pkg.rub}â‚½ / ${pkg.usdt} USDT\n`;
        if (pkg.discount) {
            message += `ğŸ”¥ Ğ¡ĞºĞ¸Ğ´ĞºĞ°: ${pkg.discount}\n`;
        }
        const pricePerVideo = (pkg.rub / pkg.generations).toFixed(2);
        message += `\nğŸ“Š Ğ¦ĞµĞ½Ğ° Ğ·Ğ° 1 Ğ²Ğ¸Ğ´ĞµĞ¾: ${pricePerVideo}â‚½\n\n`;
        message += `Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ¿Ğ¾ÑĞ¾Ğ± Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹:`;
        
        // Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº
        const paymentButtons = [];
        
        if (process.env.CARD_ENABLED === 'true') {
            paymentButtons.push([{ text: 'ğŸ’µ ĞšĞ°Ñ€Ñ‚Ğ°', callback_data: `pay_card_${packageKey}` }]);
        }
        
        if (process.env.CRYPTO_ENABLED === 'true') {
            paymentButtons.push([{ text: 'ğŸ’ ĞšÑ€Ğ¸Ğ¿Ñ‚Ğ°', callback_data: `pay_crypto_${packageKey}` }]);
        }
        
        if (process.env.STARS_ENABLED === 'true') {
            paymentButtons.push([{ text: 'â­ Stars', callback_data: `pay_stars_${packageKey}` }]);
        }
        
        paymentButtons.push([{ text: 'ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´', callback_data: 'buy' }]);
        
        await ctx.editMessageText(message, {
            reply_markup: {
                inline_keyboard: paymentButtons
            }
        });
    } catch (err) {
        console.error('âŒ Error in handleSelectPackage:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ ĞºĞ°Ñ€Ñ‚Ğ¾Ğ¹
export async function handlePayCard(ctx, packageKey = 'single') {
    try {
        ctx.session = ctx.session || {};
        ctx.session.waitingFor = 'email';
        ctx.session.selectedPackage = packageKey;
        
        const pkg = PACKAGES[packageKey];
        
        await ctx.editMessageText(
            `ğŸ’³ ĞĞ¿Ğ»Ğ°Ñ‚Ğ° ĞºĞ°Ñ€Ñ‚Ğ¾Ğ¹\n\n${pkg.emoji} ${pkg.title}: ${pkg.rub}â‚½\n\nğŸ“§ ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ email Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ñ‡ĞµĞºĞ°:`,
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´', callback_data: `select_package_${packageKey}` }]
                    ]
                }
            }
        );
    } catch (err) {
        console.error('âŒ Error in handlePayCard:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ¹
export async function handlePayCrypto(ctx, packageKey = 'single') {
    try {
        ctx.session = ctx.session || {};
        ctx.session.selectedPackage = packageKey;
        
        const pkg = PACKAGES[packageKey];
        const keyboard = createCryptoKeyboard(packageKey);
        
        await ctx.editMessageText(
            `ğŸ’ ĞĞ¿Ğ»Ğ°Ñ‚Ğ° ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ğ¾Ğ¹\n\n${pkg.emoji} ${pkg.title}: ${pkg.usdt} USDT\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ñƒ:`,
            { reply_markup: keyboard }
        );
    } catch (err) {
        console.error('âŒ Error in handlePayCrypto:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ñ‹
export async function handleCryptoSelect(ctx, crypto, packageKey = 'single') {
    try {
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('ğŸ¯ [PaymentController] handleCryptoSelect called');
        console.log(`ğŸ“Š Params: crypto=${crypto}, packageKey=${packageKey}`);
        console.log(`ğŸ‘¤ User: ${ctx.from.id} (@${ctx.from.username})`);
        
        const chains = SUPPORTED_CRYPTO[crypto];
        console.log(`ğŸ”— Available chains for ${crypto}:`, chains?.length || 0);
        
        if (!chains || chains.length === 0) {
            console.error(`âŒ No chains found for crypto: ${crypto}`);
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            return await ctx.answerCbQuery('Ğ­Ñ‚Ğ° ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ğ° Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°');
        }
        
        ctx.session = ctx.session || {};
        ctx.session.selectedPackage = packageKey;
        
        const pkg = PACKAGES[packageKey];
        if (!pkg) {
            console.error('âŒ Package not found:', packageKey);
            return await ctx.answerCbQuery('ĞŸĞ°ĞºĞµÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½');
        }
        
        const keyboard = createChainKeyboard(crypto, chains, packageKey);
        
        await ctx.editMessageText(
            `${pkg.emoji} ${pkg.title}: ${pkg.usdt} USDT\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞµÑ‚ÑŒ Ğ´Ğ»Ñ ${crypto}:`,
            { reply_markup: keyboard }
        );
    } catch (err) {
        console.error('âŒ Error in handleCryptoSelect:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ÑĞµÑ‚Ğ¸
export async function handleChainSelect(ctx, crypto, chain, packageKey = 'single') {
    try {
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('ğŸ¯ [PaymentController] handleChainSelect called');
        console.log(`ğŸ“Š Params: crypto=${crypto}, chain=${chain}, packageKey=${packageKey}`);
        console.log(`ğŸ‘¤ User: ${ctx.from.id} (@${ctx.from.username})`);
        
        const userId = ctx.from.id;
        const payCurrency = chain.replace(/_/g, ' ');
        const pkg = PACKAGES[packageKey];
        
        console.log('ğŸ’° Payment params prepared:');
        console.log(`  - userId: ${userId}`);
        console.log(`  - payCurrency: ${payCurrency}`);
        console.log(`  - amount: ${pkg.usdt} USDT`);
        console.log(`  - package: ${packageKey}`);
        console.log(`  - generations: ${pkg.generations}`);
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        console.log('ğŸš€ Calling paymentCryptoService.createPayment...');
        const payment = await paymentCryptoService.createPayment({
            userId,
            amount: pkg.usdt,
            payCurrency,
            package: packageKey
        });
        
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('ğŸ“¥ Payment service response received');
        console.log(`Response type: ${typeof payment}`);
        console.log(`Has error: ${!!payment.error}`);
        
        if (payment.error) {
            console.error('âŒ Payment creation failed with error:', payment.error);
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            return await ctx.answerCbQuery(payment.error, { show_alert: true });
        }
        
        console.log('âœ… Payment created successfully!');
        console.log(`Order ID: ${payment.orderId}`);
        
        // ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾ Ğ¸Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
        const address = payment.output.address;
        const amount = payment.input.amount; // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ input.amount Ğ²Ğ¼ĞµÑÑ‚Ğ¾ output.amount
        const destinationTag = payment.output.destinationTag;
        
        console.log('âœ… Payment created:', { orderId: payment.orderId, address, amount, destinationTag });
        
        let message = `${pkg.emoji} ${pkg.title}\n\n`;
        message += `ğŸ’ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ <code>${amount}</code> ${crypto}\n\n`;
        message += `ğŸ“ ĞĞ° Ğ°Ğ´Ñ€ĞµÑ:\n<code>${address}</code>\n\n`;
        
        if (destinationTag) {
            message += `ğŸ·ï¸ Memo/Tag: <code>${destinationTag}</code>\nâš ï¸ Ğ¢Ğ•Ğ“ ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ•Ğ!\n\n`;
        }
        
        message += `â° Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ 30 Ğ¼Ğ¸Ğ½ÑƒÑ‚ Ğ´Ğ»Ñ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹\n`;
        message += `ğŸ’¡ ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ğ½Ğ° Ğ°Ğ´Ñ€ĞµÑ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ`;
        
        const keyboard = createPaymentCryptoKeyboard(payment.orderId);
        
        // Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ÑƒĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ .inline_keyboard, Ñ‚Ğ°Ğº ĞºĞ°Ğº Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑƒĞ¶Ğµ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞºÑ‚
        await ctx.editMessageText(message, {
            parse_mode: 'HTML',
            reply_markup: keyboard
        });
    } catch (err) {
        console.error('âŒ Error in handleChainSelect:', err);
        console.error('Stack:', err.stack);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°
export async function handleCheckPayment(ctx, orderId) {
    try {
        const order = await orderService.getOrderById(orderId);
        
        if (!order) {
            return await ctx.answerCbQuery('Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½', { show_alert: true });
        }
        
        if (order.isPaid) {
            return await ctx.answerCbQuery('Ğ­Ñ‚Ğ¾Ñ‚ Ğ·Ğ°ĞºĞ°Ğ· ÑƒĞ¶Ğµ Ğ¾Ğ¿Ğ»Ğ°Ñ‡ĞµĞ½!', { show_alert: true });
        }
        
        // Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‡ĞµÑ€ĞµĞ· API
        // ĞŸĞ¾ĞºĞ° Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰Ğ°ĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼
        await ctx.answerCbQuery('â³ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ...');
        
    } catch (err) {
        console.error('âŒ Error in handleCheckPayment:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ° (Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ¸Ğ· webhook)
export async function handlePaymentSuccess(bot, orderId) {
    try {
        const order = await orderService.getOrderById(orderId);
        if (!order) return;
        
        // ĞÑ‚Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ· ĞºĞ°Ğº Ğ¾Ğ¿Ğ»Ğ°Ñ‡ĞµĞ½Ğ½Ñ‹Ğ¹
        await orderService.markAsPaid(orderId);
        
        // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        const pkg = PACKAGES[order.package];
        await userService.addPaidQuota(order.userId, pkg.generations);
        
        // ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ€ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºĞµÑˆĞ±ÑĞº Ğ´Ğ»Ñ ÑĞºÑĞ¿ĞµÑ€Ñ‚Ğ°
        const cashbackResult = await referralService.processExpertCashback(order.userId, order.amount);
        
        // Ğ•ÑĞ»Ğ¸ Ğ±Ñ‹Ğ» Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ĞµĞ½ ĞºĞµÑˆĞ±ĞµĞº, ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ÑĞºÑĞ¿ĞµÑ€Ñ‚Ğ°
        if (cashbackResult) {
            try {
                await bot.telegram.sendMessage(
                    cashbackResult.expertId,
                    `ğŸ’° ĞĞ¾Ğ²Ñ‹Ğ¹ ĞºĞµÑˆĞ±ĞµĞº!\n\nĞ’Ğ°Ñˆ Ñ€ĞµÑ„ĞµÑ€Ğ°Ğ» ÑĞ¾Ğ²ĞµÑ€ÑˆĞ¸Ğ» Ğ¿Ğ¾ĞºÑƒĞ¿ĞºÑƒ.\n\n` +
                    `ğŸ’µ Ğ¡ÑƒĞ¼Ğ¼Ğ° Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸: ${cashbackResult.originalAmount}â‚½\n` +
                    `ğŸ Ğ’Ğ°Ñˆ ĞºĞµÑˆĞ±ĞµĞº (${cashbackResult.percent}%): ${cashbackResult.amount.toFixed(2)}â‚½\n\n` +
                    `ğŸ“Š ĞĞ±Ñ‰Ğ¸Ğ¹ Ğ·Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ¾Ğº: ${(await userService.getUser(cashbackResult.expertId))?.totalCashback?.toFixed(2) || 0}â‚½`
                );
            } catch (notifyErr) {
                console.log(`Failed to notify expert ${cashbackResult.expertId}:`, notifyErr.message);
            }
        }
        
        // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        const keyboard = createAfterPaymentKeyboard();
        await bot.telegram.sendMessage(
            order.userId,
            MESSAGES.PAYMENT_SUCCESS,
            { reply_markup: keyboard.inline_keyboard }
        );
        
        console.log(`âœ… Payment ${orderId} processed successfully`);
    } catch (err) {
        console.error('âŒ Error in handlePaymentSuccess:', err);
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº "Ğ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğµ"
export async function handleAbout(ctx) {
    try {
        await ctx.editMessageText(MESSAGES.ABOUT, { reply_markup: ABOUT_KEYBOARD });
    } catch (err) {
        console.error('âŒ Error in handleAbout:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ñ€ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹
export async function handleReferral(ctx) {
    try {
        if (!REFERRAL_ENABLED) {
            return await ctx.answerCbQuery('â³ Ğ ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ° ÑĞºĞ¾Ñ€Ğ¾ Ğ±ÑƒĞ´ĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°!', { show_alert: true });
        }
        
        await ctx.editMessageText(
            'ğŸ ĞŸÑ€Ğ¸Ğ²ĞµĞ´Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ° Ğ·Ğ° Ğ±Ğ¾Ğ½ÑƒÑ\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ñ€ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ÑÑÑ‹Ğ»ĞºĞ¸:',
            { reply_markup: REFERRAL_TYPE_KEYBOARD }
        );
    } catch (err) {
        console.error('âŒ Error in handleReferral:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¾Ğ¹ Ñ€ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ÑÑÑ‹Ğ»ĞºĞ¸
export async function handleRefUser(ctx) {
    try {
        const userId = ctx.from.id;
        const botName = process.env.BOT_NAME || 'meemee_bot';
        const refLink = referralService.generateUserReferralLink(userId, botName);
        
        await ctx.editMessageText(
            MESSAGES.REFERRAL_INFO + `\n\n${refLink}`,
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ğŸ“¤ ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ', url: `https://t.me/share/url?url=${encodeURIComponent(refLink)}` }],
                        [{ text: 'ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´', callback_data: 'referral' }]
                    ]
                }
            }
        );
    } catch (err) {
        console.error('âŒ Error in handleRefUser:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ÑĞºÑĞ¿ĞµÑ€Ñ‚Ğ½Ğ¾Ğ¹ Ñ€ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ÑÑÑ‹Ğ»ĞºĞ¸
export async function handleRefExpert(ctx) {
    try {
        const userId = ctx.from.id;
        const botName = process.env.BOT_NAME || 'meemee_bot';
        const refLink = referralService.generateExpertReferralLink(userId, botName);
        
        const stats = await referralService.getReferralStats(userId);
        
        // Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚ Ğ¸Ğ· ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³Ğ°
        const { EXPERT_CASHBACK_PERCENT } = await import('../config.js');
        
        let message = MESSAGES.EXPERT_REFERRAL_INFO(EXPERT_CASHBACK_PERCENT) + `\n\n${refLink}\n\n`;
        message += `ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:\n`;
        message += `ğŸ‘¥ ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¾: ${stats.expertReferrals}\n`;
        message += `ğŸ’° Ğ—Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾: ${stats.totalCashback?.toFixed(2) || 0}â‚½`;
        
        await ctx.editMessageText(
            message,
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ğŸ“¤ ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ', url: `https://t.me/share/url?url=${encodeURIComponent(refLink)}` }],
                        [{ text: 'ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´', callback_data: 'referral' }]
                    ]
                }
            }
        );
    } catch (err) {
        console.error('âŒ Error in handleRefExpert:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Stars (Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°)
export async function handlePayStarsSoon(ctx) {
    await ctx.answerCbQuery('â­ Telegram Stars ÑĞºĞ¾Ñ€Ğ¾ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹!', { show_alert: true });
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ»Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ°Ğ±Ğ¸Ğ½ĞµÑ‚Ğ°
export async function handleProfile(ctx) {
    try {
        const userId = ctx.from.id;
        const user = await userService.getUser(userId);
        const generations = await generationService.getUserGenerations(userId);
        const referralStats = await referralService.getReferralStats(userId);
        
        if (!user) {
            return await ctx.answerCbQuery('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ', { show_alert: true });
        }
        
        const message = MESSAGES.PROFILE(user, generations, referralStats);
        
        await ctx.editMessageText(message, {
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ğŸ“œ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹', callback_data: 'profile_history' }],
                    [{ text: 'ğŸ’³ ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ²Ğ¸Ğ´ĞµĞ¾', callback_data: 'buy' }],
                    [{ text: 'ğŸ”™ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ', callback_data: 'main_menu' }]
                ]
            }
        });
    } catch (err) {
        console.error('âŒ Error in handleProfile:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}

// ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
export async function handleProfileHistory(ctx) {
    try {
        const userId = ctx.from.id;
        const generations = await generationService.getUserGenerations(userId);
        
        if (!generations || generations.length === 0) {
            return await ctx.editMessageText(
                'ğŸ“œ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹ Ğ¿ÑƒÑÑ‚Ğ°\n\nĞ’Ñ‹ ĞµÑ‰Ñ‘ Ğ½Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ»Ğ¸ Ğ½Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ğ¸Ğ´ĞµĞ¾.',
                {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'ğŸ¬ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ²Ğ¸Ğ´ĞµĞ¾', callback_data: 'catalog' }],
                            [{ text: 'ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´', callback_data: 'profile' }]
                        ]
                    }
                }
            );
        }
        
        let message = 'ğŸ“œ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹:\n\n';
        
        generations.forEach((gen, idx) => {
            const statusEmoji = gen.status === 'done' ? 'âœ…' : gen.status === 'failed' ? 'âŒ' : gen.status === 'processing' ? 'â³' : 'ğŸ•';
            const date = new Date(gen.createdAt).toLocaleString('ru-RU');
            message += `${idx + 1}. ${statusEmoji} ${gen.memeName}\n`;
            message += `   ğŸ‘¤ Ğ˜Ğ¼Ñ: ${gen.name} (${gen.gender === 'male' ? 'Ğœ' : 'Ğ–'})\n`;
            message += `   ğŸ“… ${date}\n`;
            
            if (gen.status === 'failed' && gen.error) {
                message += `   âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ°: ${gen.error}\n`;
            }
            message += '\n';
        });
        
        // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸ ĞµÑĞ»Ğ¸ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
        const keyboard = {
            inline_keyboard: [
                [{ text: 'ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ', callback_data: 'profile' }],
                [{ text: 'ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ', callback_data: 'main_menu' }]
            ]
        };
        
        await ctx.editMessageText(message, { reply_markup: keyboard });
    } catch (err) {
        console.error('âŒ Error in handleProfileHistory:', err);
        await ctx.answerCbQuery('ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°');
    }
}
